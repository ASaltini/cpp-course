\begin{frame}[fragile]{Signed/Unsigned}
  \vfill
  \begin{lstlisting}
#include <iostream>
int main(){
  signed int a = -50;
  unsigned int b = -50;
  std::cout << a << std::endl;
  std::cout << b << std::endl;
  return 0;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \lstinline$unsigned$ è un tipo di intero senza segno
    \begin{itemize}
      \item range doppio, bit del segno usato per le cifre
      \item comportamento inatteso con numeri negativi
    \end{itemize}
    \vfill
    \item \lstinline$signed$ è generalmente sottointeso
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Typedef}
  \vfill
  \begin{lstlisting}
#include <iostream>
typedef unsigned int uint;
int main(){
  uint a = 6;
  std::cout << a << std::endl;
  return 0;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \lstinline$typedef$ definisce un nuovo tipo
    \begin{itemize}
      \item abbrevia la scrittura
      \item modifica flessibile su programmi lunghi
    \end{itemize}
    \vfill
    \item Alcuni compilatori definiscono già \lstinline$uint$, ma è consigliabile
    ridefinirlo con un typedef per portabilità
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Casting}
  \vfill
  \begin{lstlisting}
#include <iostream>
int main(){
  char a = 'A';
  std::cout << a << std::endl;
  std::cout << static_cast<int>(a) << std::endl;
  std::cout << dynamic_cast<int>(a) << std::endl;
  return 0;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item Conversione di dati da un tipo ad un altro
    \begin{itemize}
      \item \lstinline$static_cast$: più sicuro, più veloce
      \item \lstinline$dynamic_cast$: più flessibile
      \item differenze irrisorie sui tipi standard
    \end{itemize}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Casting}
  \vfill
  \begin{lstlisting}
#include <iostream>
int main(){
  char a = 'A';
  std::cout << a << std::endl;
  std::cout << (int) a << std::endl;
  return 0;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item Legacy C-style cast: \lstinline$(int) a$
    \begin{itemize}
      \item sconsigliato, comportamento inaffidabile
    \end{itemize}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{itemize}
    \item Matematica: \(f : A \to B\)
    \begin{itemize}
      \item \(A\) dominio
      \item \(B\) codominio
      \item associa ciascun elemento di \(A\) ad un elemento di \(B\)
    \end{itemize}
    \vfill
    \item Funzioni a più input: \(f : A_1 \times A_2 \to B\)
    \begin{itemize}
      \item coppia di valori da \(A_1\) e \(A_2\) come input
      \item più in generale, n-ple di valori
    \end{itemize}
    \vfill
    \item Informatica: \alert{tipi} prendono il posto degli insiemi
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{itemize}
    \item Funzioni \alert{pure}
    \begin{itemize}
      \item non modificano i valori di input
      \item il valore di output dipende \alert{solo} dai valori di input
      \item non producono lettura/scrittura a schermo
    \end{itemize}
    \vfill
    \item Funzioni \alert{impure}
    \begin{itemize}
      \item possono modificare gli input
      \item possono utilizzare valori casuali, date, ore
      \item possono leggere o scrivere a schermo
    \end{itemize}
    \vfill
    \item La sintassi del \CC\ non le distingue
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{lstlisting}
#include <iostream>
int twice(int x) {
  return 2*x;
}
int main() {
  int a = 3;
  std::cout << twice(a) << std::endl;
  std::cout << a << std::endl;
  return 0;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \(\text{\lstinline$twice$} : \text{\lstinline$int$} \to \text{\lstinline$int$} :: x \mapsto 2x\)
    \item \(\text{\lstinline$main$} : \text{\lstinline$void$} \to \text{\lstinline$int$}\)
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{lstlisting}[firstnumber=2]
int twice(int x) {
  return 2*x;
}\end{lstlisting}
  \vfill
  \begin{itemize}
    \item \alert{Definizione} della funzione
    \begin{itemize}
      \item il primo \lstinline$int$ è il tipo di output
      \item segue il nome della funzione
      \item l'\lstinline$int$ tra parentesi è il tipo di input
      \item \lstinline$x$ indica il nome della variabile
      \item il blocco \lstinline${ ... }$ è l'\alert{implementazione}
    \end{itemize}
  \end{itemize}
    \vfill
    \begin{lstlisting}[firstnumber=7]
  std::cout << twice(a) << std::endl;\end{lstlisting}
    \vfill
    \begin{itemize}
      \item \alert{Chiamata} alla funzione
    \end{itemize}
      \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{lstlisting}
#include <iostream>
int pow(int x, int y) {
  int z = 1;
  for(int i = 0; i < y; i++) z *= x;
  return z;
}
int main() {
  std::cout << pow(2,3) << std::endl;
  return 0;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \(\text{\lstinline$pow$} : \text{\lstinline$int$} \times \text{\lstinline$int$} \to \text{\lstinline$int$} :: (x,y) \mapsto x^y\)
    \vfill
    \item Funzione a due input
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{lstlisting}
#include <iostream>
int two() { return 2; }
int main() {
  std::cout << two() << std::endl;
  return 0;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \(\text{\lstinline$two$} : \text{\lstinline$void$} \to \text{\lstinline$int$} :: 2\)
    \vfill
    \item Funzione senza input
    \vfill
    \item Chiamata con \lstinline$two()$
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{lstlisting}
#include <iostream>
int twice(int);
int main() {
  int a = 3;
  std::cout << twice(a) << std::endl;
  std::cout << a << std::endl;
  return 0;
}
int twice(int x) { return 2*x; }
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \lstinline$int twice(int);$ è la \alert{dichiarazione} o \alert{prototipo}
    \vfill
    \item \lstinline$int twice(int x) { return 2*x; }$ è la \alert{definizione}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{itemize}
    \item La dichiarazione dice che esiste una funzione
    \begin{itemize}
      \item deve precedere il primo utilizzo della funzione
      \item buona occasione per commentare
    \end{itemize}
    \vfill
    \item La definizione implementa la funzione
    \begin{itemize}
      \item senza di dichiarazione deve precedere il primo utilizzo
    \end{itemize}
    \vfill
    \item Separarle è una buona abitudine
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{lstlisting}
#include <iostream>
int fibonacci(int);
int main() {
  std::cout << fibonacci(8) << std::endl;
  return 0;
}
int fibonacci(int n) {
  int f;
  if (n == 0) f = 0;
  else  if (n == 1) f = 1;
        else f = fibonacci(n-1) + fibonacci(n-2);
  return f;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item Funzione \alert{ricorsiva}: chiama sé stessa
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{lstlisting}
#include <iostream>
void hello(int);
int main() {
  hello(5);
  return 0;
}
void hello(int x) {
  for(int i = 0; i < x; i++) {
    std::cout << "Hello, World!" << std::endl;
  }
  return;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \alert{Procedura}: funzione senza tipo di output
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{itemize}
    \item Passaggio di parametri \alert{by value}
    \begin{itemize}
      \item \lstinline$int funzione(int)$
      \item crea una copia degli argomenti della funzione
      \item impossibile modificare gli argomenti
      \item occupa più memoria, sconsigliato per molti dati
    \end{itemize}
    \vfill
    \item Passaggio di parametri \alert{by reference}
    \begin{itemize}
      \item \lstinline$int funzione(int&)$
      \item la funzione ha accesso diretto agli argomenti
      \item necessario per certe applicazioni
    \end{itemize}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{lstlisting}
#include <iostream>
void swap(int,int)
int main() {
  int a = 1, b = 0;
  std::cout << a << " " << b << std::endl;
  swap(a,b);
  std::cout << a << " " << b << std::endl;
  return 0;
}
void swap(int x, int y) {
  int z = x;
  x = y;
  y = z;
  return;
}
  \end{lstlisting}
  \vfill
\end{frame}

\begin{frame}[fragile]{Funzioni}
  \vfill
  \begin{lstlisting}
#include <iostream>
void swap(int&,int&)
int main() {
  int a = 1, b = 0;
  std::cout << a << " " << b << std::endl;
  swap(a,b);
  std::cout << a << " " << b << std::endl;
  return 0;
}
void swap(int& x, int& y) {
  int z = x;
  x = y;
  y = z;
  return;
}
  \end{lstlisting}
  \vfill
\end{frame}

\begin{frame}[fragile]{Un problema pratico}
  \vfill
  \begin{lstlisting}
#include <iostream>
int main(){
  signed char a = 26;
  a += 5;
  std::cout << static_cast<int>(a) << std::endl;
  a -= 42;
  std::cout << static_cast<int>(a) << std::endl;
  return 0;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \lstinline$signed/unsigned char$ come intero
    \begin{itemize}
      \item minor utilizzo di memoria
      \item maggior tempo di calcolo (su macchine moderne)
      \item no input diretto (serve variabile di appoggio)
    \end{itemize}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Operator overloading}
  \vfill
  \begin{lstlisting}
#include <iostream>
typedef signed char schar;
std::istream& operator>>(std::istream&,schar&);
std::ostream& operator<<(std::ostream&,schar&);
int main(){
  schar a;
  std::cin >> a;
  a += 5;
  std::cout << a << std::endl;
  return 0;
}
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item \lstinline$typedef$ per evitare conflitti
    \vfill
    \item ridefiniamo \lstinline$>>$ e \lstinline$<<$ (\alert{overloading})
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{Operator overloading}
  \vfill
  \begin{lstlisting}[firstnumber=11]
...
std::istream& operator>>(std::istream& input,schar& x) {
  int y;
  input >> y;
  x = y;
  return input;
}
std::ostream& operator<<(std::ostream& output,schar& x) {
  output << static_cast<int>(x);
  return output;
}
  \end{lstlisting}
  \vfill
\end{frame}

\begin{frame}[fragile]{Strutture}
  \vfill
  \begin{lstlisting}
#include <iostream>
struct frutto {
  int m;    //massa
  double p; //prezzo
};
int main(){
  frutto mela;
  mela.m = 250;
  mela.p = 0.28;
  std::cout << 1e3*mela.p/mela.m << std::endl;
  return 0;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \lstinline$struct$ crea un nuovo tipo che contiene più variabili
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{itemize}
    \item In OOP si creano \alert{oggetti}
    \begin{itemize}
      \item variabili membro
      \item funzioni membro
    \end{itemize}
    \vfill
    \item Una \alert{classe} definisce un \alert{tipo} di oggetto
    \vfill
    \item L'oggetto vero e proprio è una variabile
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=2]
class Rett {
  private:
    int b, h;
  public:
    Rett();
    Rett(int,int);
    int area();
    void draw();
};
...
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \lstinline$private$ introduce membri inaccessibili dall'esterno
    \vfill
    \item \lstinline$public$ introduce membri accessibili dall'esterno
    \vfill
    \item Funzioni pubbliche possono alterare membri privati
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=2]
class Rett {
  private:
    int b, h;
  public:
    Rett();
    Rett(int,int);
    int area();
    void draw();
};
...
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item \alert{Costruttori}: \lstinline$Rett()$ e \lstinline$Rett(int,int)$
    \begin{itemize}
      \item vengono invocati quando si dichiara l'oggetto
    \end{itemize}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=16]
...
Rett::Rett() { return; }
Rett::Rett(int x, int y) {
  this->b = x;
  this->h = y;
  return;
}
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item Implementazione dei costruttori
    \begin{itemize}
      \item all'esterno dell'oggetto
      \item preceduti dal nome dell'oggetto
    \end{itemize}
    \vfill
    \item \lstinline$this->$ indica che \lstinline$b$ e \lstinline$h$ sono membri
    \begin{itemize}
      \item si può omettere
      \item rischio di conflitto con variabili/funzioni globali
    \end{itemize}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=22]
...
int Rett::area() {
  return this->b*this->h;
}
void Rett::draw() {
  for(int i = 0; i < this->h; i++) {
    for(int j = 0; j < this->b; j++) {
      std::cout << "*";
    }
    std::cout << std::endl;
  }
  return;
}
  \end{lstlisting}
  \vfill
  \begin{itemize}
    \item Implementazione delle altre funzioni
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=10]
...
int main(){
  Rett a(8,3);
  a.draw();
  std::cout << "Area = " << a.area() << std::endl;
  return 0;
}
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item \lstinline$Rett a(8,3);$ chiama \lstinline$Rett(int,int)$
    \item \lstinline$Rett a;$ chiama \lstinline$Rett()$
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=10]
...
int main(){
  Rett a(8,3);
  a.draw();
  std::cout << "Area = " << a.b*a.h << std::endl;
  return 0;
}
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item Errore: \lstinline$b$ e \lstinline$h$ sono privati
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=2]
...
class Rett {
private:
  int b, h;
public:
  Rett();
  Rett(int,int);
  int area();
  void draw();
  bool operator==(const Rett&) const;
};
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item Overload di \lstinline$==$ per la classe Rett
    \vfill
    \item \lstinline$const$ indica che non cambia l'oggetto
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=37]
...
bool Rett::operator==(const Rett& a) const{
  bool eq = 0;
  if (this->b == a.b && this->h == a.h) eq = 1;
  if (this->b == a.h && this->h == a.b) eq = 1;
  return eq;
}
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item Implementazione, all'esterno della classe
    \vfill
    \item Buona abitudine: passare gli argomenti by reference
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=2]
...
class Rett {
private:
  int b, h;
public:
  Rett();
  Rett(int,int);
  int area();
  void draw();
  friend bool operator==(const Rett&,const Rett&);
};
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item Alternativa: overload come funzione \alert{libera}
    \vfill
    \item \lstinline$friend$ permette all'operatore di accedere a \lstinline$private$
    \begin{itemize}
      \item non importa dove viene scritto
    \end{itemize}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=37]
...
bool operator==(const Rett& a, const Rett& b) {
  bool eq = 0;
  if (a.b == b.b && a.h == b.h) eq = 1;
  if (a.b == b.h && a.h == b.b) eq = 1;
  return eq;
}
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item L'operatore \alert{non} è un membro della classe
    \begin{itemize}
      \item per questo è necessario includerlo come \lstinline$friend$
      \item spesso è preferibile avere operatori membro
    \end{itemize}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=2]
...
class Rett {
  private:
    int b, h;
  public:
    Rett();
    Rett(int,int);
    int area();
    void draw();
    Rett& operator+=(const Rett&);
    Rett operator+(const Rett&) const;
    bool operator==(const Rett&);
};
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item Overload di \lstinline$+$ e \lstinline$+=$
    \begin{itemize}
      \item \lstinline$+$ ha come output un oggetto
      \item \lstinline$+=$ ha come output un riferimento all'oggetto
    \end{itemize}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=49]
...
Rett& Rett::operator+=(const Rett& a) {
  this->b = this->b + a.b;
  this->h = this->h + a.h;
  return *this;
}
Rett Rett::operator+(const Rett& a) const {
  int b = this->b + a.b;
  int h = this->h + a.h;
  return Rett(b,h);
}
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item Implementazione
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}[fragile]{OOP -- Object Oriented Programming}
  \vfill
  \begin{lstlisting}[firstnumber=49]
...
Rett operator+(const Rett& a, const Rett& b){
  Rett x = a;
  x += b;
  return (x);
}
...\end{lstlisting}
  \vfill
  \begin{itemize}
    \item A volte conviene avere \lstinline$+$ come funzione libera
    \begin{itemize}
      \item più flessibile con conversioni
    \end{itemize}
    \vfill
    \item Definita in termini di \lstinline$+=$, \alert{non} ha bisogno di \lstinline$friend$
  \end{itemize}
  \vfill
\end{frame}
